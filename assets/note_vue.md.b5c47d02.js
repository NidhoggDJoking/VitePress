import{_ as r,o as d,c as o,b as a,d as e,e as c,a as s,r as n}from"./app.36d1cbb8.js";const x=JSON.parse('{"title":"Vue 源码解析","description":"","frontmatter":{"outline":"deep"},"headers":[{"level":2,"title":"Vue2","slug":"vue2","link":"#vue2","children":[]},{"level":2,"title":"Vue3","slug":"vue3","link":"#vue3","children":[]},{"level":2,"title":"轮子","slug":"轮子","link":"#轮子","children":[]}],"relativePath":"note/vue.md","lastUpdated":1686045323000}'),i={name:"note/vue.md"},l={id:"vue-源码解析",tabindex:"-1"},u=a("a",{class:"header-anchor",href:"#vue-源码解析","aria-hidden":"true"},"#",-1),h=s('<hr><h2 id="vue2" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2" aria-hidden="true">#</a></h2><hr><h2 id="vue3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3" aria-hidden="true">#</a></h2><details class="details custom-block"><summary>Vue3 相对 Vue2 有以下性能上的优化：</summary><p>1.更快的渲染速度：<code>Vue3</code> 中引入了新的响应式系统<code>Proxy</code>，它比 <code>Vue2</code> 的 <code>Object.defineProperty()</code> 实现更快，能够提高组件的渲染性能。</p><p>2.更小的包大小：<code>Vue3</code> 使用 <code>Tree-shaking</code> 技术，打包时只会将用到的代码打入最终 <code>bundle</code>，使得包的大小更小，减少了用户加载和解析的时间。</p><p>3.更少的内存占用：<code>Vue3</code> 在渲染组件时使用了更少的内部对象，避免了过多对象的创建和回收，减少了内存占用。</p><p>4.静态节点提取：<code>Vue3</code> 通过编译阶段对静态节点的分析，可以在运行时跳过对这些节点的处理，减少了不必要的计算。</p></details><h2 id="轮子" tabindex="-1">轮子 <a class="header-anchor" href="#轮子" aria-hidden="true">#</a></h2><p><a href="https://www.lodashjs.com/" target="_blank" rel="noreferrer">lodash</a></p><p><a href="https://smartprocure.github.io/futil-js/" target="_blank" rel="noreferrer">futil</a></p>',8);function p(_,v,V,f,m,b){const t=n("Badge");return d(),o("div",null,[a("h1",l,[e("Vue 源码解析"),c(t,{type:"tip",text:"八股文"}),e(),u]),h])}const k=r(i,[["render",p]]);export{x as __pageData,k as default};
